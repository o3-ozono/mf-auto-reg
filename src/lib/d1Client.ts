import type { D1Database, D1Result } from '@cloudflare/workers-types';

/**
 * Interface for the structured transaction data stored in D1.
 */
export interface TransactionData {
  id: string;                 // Primary Key (UUID)
  source_email_id: string; // Unique identifier derived from the source email
  parsed_data: Record<string, any>; // The structured transaction data
  mf_status: 'pending' | 'registered' | 'error'; // Status of MoneyForward registration
  created_at: string;       // ISO 8601 timestamp
  updated_at: string;       // ISO 8601 timestamp
}

/**
 * Interface for the data needed to register a new transaction.
 * Excludes fields generated by the database or system (`id`, `mf_status`, `created_at`, `updated_at`).
 */
export type NewTransactionData = Omit<TransactionData, 'id' | 'mf_status' | 'created_at' | 'updated_at'>;

/**
 * Interface for the D1 Client, defining methods for transaction management.
 */
export interface D1Client {
  /**
   * Checks if a transaction with the given source_email_id already exists.
   * @param source_email_id - The unique identifier from the source email.
   * @returns True if a duplicate exists, false otherwise.
   */
  checkDuplicate(source_email_id: string): Promise<boolean>;

  /**
   * Registers a new transaction in the database.
   * @param data - The data for the new transaction.
   * @returns The UUID of the newly created transaction record.
   * @throws Error if the insertion fails (e.g., duplicate source_email_id).
   */
  registerTransaction(data: NewTransactionData): Promise<string>;

  /**
   * Updates the MoneyForward registration status of an existing transaction.
   * Also updates the `updated_at` timestamp.
   * @param id - The UUID of the transaction to update.
   * @param status - The new status ('pending', 'registered', or 'error').
   * @throws Error if the transaction is not found or the update fails.
   */
  updateTransactionStatus(id: string, status: TransactionData['mf_status']): Promise<void>;
}

/**
 * Creates and returns a D1Client instance.
 * This factory function encapsulates the D1 database binding.
 *
 * @param db - The D1Database instance (typically from `env.DB`).
 * @returns An object implementing the D1Client interface.
 */
export function createD1Client(db: D1Database): D1Client {

  const checkDuplicate = async (source_email_id: string): Promise<boolean> => {
    // Check if a record with the given source_email_id already exists.
    const query = 'SELECT 1 FROM transactions WHERE source_email_id = ? LIMIT 1';
    try {
      const statement = db.prepare(query).bind(source_email_id);
      // statement.first() will return an object if a match is found, otherwise null.
      const result = await statement.first();
      // If result is not null, a record exists.
      return result !== null;
    } catch (e: any) {
      console.error('Error checking for duplicate transaction:', e);
      // Rethrow the error to be handled by the caller (workflow node)
      throw new Error(`Failed to check duplicate transaction: ${e.message}`);
    }
  };

  const registerTransaction = async (data: NewTransactionData): Promise<string> => {
    const newId = crypto.randomUUID();
    const parsedDataJson = JSON.stringify(data.parsed_data);
    const query = 'INSERT INTO transactions (id, source_email_id, parsed_data, mf_status) VALUES (?, ?, ?, ?)';
    // Initial status is 'pending'
    const initialStatus = 'pending';

    try {
      const statement = db.prepare(query).bind(
        newId,
        data.source_email_id,
        parsedDataJson,
        initialStatus
      );
      const info: D1Result = await statement.run();

      // Check if the insert was successful (D1Result indicates success/failure)
      // Note: D1's run() might not throw an error for certain constraint violations
      // depending on configuration or future updates. Explicit success check is safer.
      if (!info.success) {
         // If D1 indicates failure, throw an error using the provided message or a generic one.
         // Specific error handling (like UNIQUE constraint) is deferred to the catch block.
         throw new Error(`Failed to register transaction: ${info.error || 'Unknown D1 error'}`);
      }

      console.log(`Successfully registered transaction ${newId} from email ${data.source_email_id}`);
      return newId;

    } catch (e: unknown) { 
      console.error(`Error registering transaction from email ${data.source_email_id}:`, e);

      let finalErrorMessage: string;

      // Check if it's an Error instance and if it's a UNIQUE constraint violation
      if (e instanceof Error && e.message.includes('UNIQUE constraint failed')) {
        // Set specific error message for duplicate entries
        finalErrorMessage = `Transaction with source_email_id '${data.source_email_id}' already exists.`;
      } else {
        // Construct generic message for all other errors
        const baseMessage = e instanceof Error ? e.message : String(e);
        finalErrorMessage = `Failed to register transaction: ${baseMessage}`;
      }

      // Throw the determined error message
      throw new Error(finalErrorMessage);
    }
  };

  const updateTransactionStatus = async (id: string, status: TransactionData['mf_status']): Promise<void> => {
    // Update mf_status and updated_at for the given transaction ID.
    // Use CURRENT_TIMESTAMP for updated_at as D1 might not support ON UPDATE triggers easily.
    const query = 'UPDATE transactions SET mf_status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?';
    try {
      const statement = db.prepare(query).bind(status, id);
      const info: D1Result = await statement.run();

      // Check if the update was successful and if any row was actually changed.
      if (!info.success) {
        throw new Error(`Failed to update transaction status: ${info.error || 'Unknown D1 error'}`);
      }

      // Check if a row was actually updated. If changes = 0, the ID was not found.
      if (info.meta.changes === 0) {
        throw new Error(`Transaction with ID '${id}' not found for status update.`);
      }

      console.log(`Successfully updated transaction ${id} status to ${status}`);

    } catch (e: unknown) {
      console.error(`Error updating transaction status for ID ${id}:`, e);
      // Rethrow the error
      const errorMessage = e instanceof Error ? e.message : String(e);
      throw new Error(`Failed to update transaction status: ${errorMessage}`);
    }
  };

  return {
    checkDuplicate,
    registerTransaction,
    updateTransactionStatus,
  };
}

// Type helper for environment variables expected by Workers using this client
export interface Env {
  DB: D1Database;
  // Add other environment variables if needed
} 